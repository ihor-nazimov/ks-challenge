#based on
#https://medium.com/analytics-vidhya/deploying-a-machine-learning-model-as-a-flask-app-on-heroku-part-1-b5e194fed16d

import os
import tempfile

from flask import Flask, render_template, request, flash, redirect, url_for
from werkzeug.utils import secure_filename
import pandas as pd
import pickle

#Ініціалізація веб-застосунку
#Тимчасовий каталог та дозволені розширення запитів

# UPLOAD_FOLDER = '/tmp/flask'
UPLOAD_FOLDER = tempfile.TemporaryDirectory().name
os.mkdir(UPLOAD_FOLDER)
ALLOWED_EXTENSIONS = {'json'}

app = Flask(__name__)

#Ключ захисту сеансу
# generated by os.urandom(24)
app.secret_key = b'\xd4\xef\x88s\xfc^\xfb\xed\xd1\x8d\xab\xa8v\xa9\x17;\xfe\xf9@\x92x\xfe\x13S'
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

#Завантаження моделей стандартизації даних та логістичної регресії
with open('./lib/models/LogisticRegression_simple_6_46.pkl', 'rb') as file:
    simple_model = pickle.load(file)

with open('./lib/models/Scaler.pkl', 'rb') as file:
    scaler = pickle.load(file)
with open('./lib/models/LogisticRegression_scaled_full.pkl', 'rb') as file:
    model = pickle.load(file)
logit_features = ['feature_46', 'feature_35',
       'feature_6', 'feature_40', 'feature_47',
       'feature_12', 'feature_4', 'feature_31',
       'feature_18', 'feature_32', 'feature_3']

#######   Обробка запитів спрощеною моделлю   #######

@app.route('/', methods=['GET', 'POST'])
def main():
    # обробка запиту на завантаження інтерфейсу
    if request.method == 'GET':
        return(render_template('main.html'))   

    # обробка форми
    if request.method == 'POST':
        feature_6 =  request.form['feature_6']
        feature_46 =  request.form['feature_46']
        
        # перетворення даних форми         
        input_variables = pd.DataFrame([[feature_6, feature_46]],
        columns=['feature_6', 'feature_46'], dtype=float)

        # класифікація з використанням спрощеної моделі    
        prediction = simple_model.predict(input_variables)[0]
        prediction_proba = simple_model.predict_proba(input_variables)[0,1]
        if prediction == 0.0:
            prediction = "Subscriber is not a driver"
        else: 
            prediction = "Subscriber is a driver"
        
        # відправка результатів класифікації
        return render_template('main.html', 
            result={"class":prediction, 
                "prediction_proba": "{:.3f}".format(prediction_proba)}
        )

#######   Обробка запитів повною моделлю (API)   #######

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

@app.route('/process_json', methods=['GET', 'POST'])
def process_json():
    # обробка запиту на завантаження інтерфейсу
    if request.method == 'GET':
        app.logger.info('GET catched')
        return render_template('process_json.html')    

    # обробка запиту на обробку файлу
    if request.method == 'POST':
        # завантаження файлу
        app.logger.info('POST catched')
        if 'file' not in request.files:
            flash('No file part')
            return redirect(request.url)
        file = request.files['file']
        app.logger.info('filename=' + file.filename)

        if file.filename == '':
            flash('No selected file')
            return redirect(request.url)
        if file and allowed_file(file.filename):
            filename = secure_filename(file.filename)

            # збереження файлу до тимчасового каталогу
            fullfilename = os.path.join(app.config['UPLOAD_FOLDER'], filename)
            file.save(fullfilename)
            app.logger.info('Saved:' + fullfilename)

            # завантаження та стандартизація даних
            test_data = pd.read_json(fullfilename)
            print(test_data.shape)
            print('Scaling...')
            X_scaled = pd.DataFrame(scaler.transform(test_data[logit_features]), 
                                    columns=logit_features, index=test_data.index)
            print('Scaling completed')
            
            # класифікація даних
            print('Prediction...')
            y_pred = model.predict(X_scaled)
            print('Prediction completed')
            y_pred_proba = model.predict_proba(X_scaled)[:,1]

            # агрегація результатів класифікації
            predicted_test_data = test_data.join(pd.DataFrame({'y_pred':y_pred, 'y_pred_proba':y_pred_proba}, index=test_data.index))
            predicted_test_data_agg = predicted_test_data[{'id', 'target', 'y_pred_proba'}].groupby('id').mean()
            predicted_test_data_agg['y_pred_agg'] = (predicted_test_data_agg.y_pred_proba >= 0.5).mul(1)
            predicted_test_data_agg['valid_predict'] = predicted_test_data_agg.target == predicted_test_data_agg.y_pred_agg

            # повернення результатів у тілі відповіді в форматі JSON 
            response = app.response_class(
                response=predicted_test_data_agg[{'target', 'y_pred_agg', 'y_pred_proba', 'valid_predict'}]
                    .groupby('id').mean().to_json(),
                status=200,
                mimetype='application/json'
            )
            return response
    return render_template('process_json.html')


if __name__ == '__main__':
    app.run(debug = True)